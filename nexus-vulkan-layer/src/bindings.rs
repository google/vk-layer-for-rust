// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __BIONIC__: u32 = 1;
pub const __USE_BSD: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __bos_level: u32 = 0;
pub const __ANDROID_API_FUTURE__: u32 = 10000;
pub const __ANDROID_API_G__: u32 = 9;
pub const __ANDROID_API_I__: u32 = 14;
pub const __ANDROID_API_J__: u32 = 16;
pub const __ANDROID_API_J_MR1__: u32 = 17;
pub const __ANDROID_API_J_MR2__: u32 = 18;
pub const __ANDROID_API_K__: u32 = 19;
pub const __ANDROID_API_L__: u32 = 21;
pub const __ANDROID_API_L_MR1__: u32 = 22;
pub const __ANDROID_API_M__: u32 = 23;
pub const __ANDROID_API_N__: u32 = 24;
pub const __ANDROID_API_N_MR1__: u32 = 25;
pub const __ANDROID_API_O__: u32 = 26;
pub const __ANDROID_API_O_MR1__: u32 = 27;
pub const __ANDROID_API_P__: u32 = 28;
pub const __ANDROID_API_Q__: u32 = 29;
pub const __ANDROID_API_R__: u32 = 30;
pub const __ANDROID_API_S__: u32 = 31;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_FAST8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const __PRI_64_prefix: &[u8; 2usize] = b"l\0";
pub const __PRI_PTR_prefix: &[u8; 2usize] = b"l\0";
pub const __PRI_FAST_prefix: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdMAX: &[u8; 3usize] = b"jd\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIiMAX: &[u8; 3usize] = b"ji\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoMAX: &[u8; 3usize] = b"jo\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuMAX: &[u8; 3usize] = b"ju\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxMAX: &[u8; 3usize] = b"jx\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXMAX: &[u8; 3usize] = b"jX\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdMAX: &[u8; 3usize] = b"jd\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNiMAX: &[u8; 3usize] = b"ji\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoMAX: &[u8; 3usize] = b"jo\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuMAX: &[u8; 3usize] = b"ju\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxMAX: &[u8; 3usize] = b"jx\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const NATIVE_HANDLE_MAX_FDS: u32 = 1024;
pub const NATIVE_HANDLE_MAX_INTS: u32 = 1024;
pub const DRV_MAX_PLANES: u32 = 4;
pub const DRV_MAX_FDS: u32 = 5;
extern "C" {
    pub fn android_get_application_target_sdk_version() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_get_device_api_level() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __uintptr_t = ::std::os::raw::c_ulong;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_fast16_t = i64;
pub type uint_fast16_t = u64;
pub type int_fast32_t = i64;
pub type uint_fast32_t = u64;
pub type uintmax_t = u64;
pub type intmax_t = i64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ARect {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
pub type ARect_value_type = i32;
#[test]
fn bindgen_test_layout_ARect() {
    const UNINIT: ::std::mem::MaybeUninit<ARect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ARect>(),
        16usize,
        concat!("Size of: ", stringify!(ARect))
    );
    assert_eq!(
        ::std::mem::align_of::<ARect>(),
        4usize,
        concat!("Alignment of ", stringify!(ARect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ARect),
            "::",
            stringify!(bottom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__i: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numerator: intmax_t, __denominator: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __s: *const u32,
        __end_ptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __s: *const u32,
        __end_ptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R8G8B8A8_UNORM: AHardwareBuffer_Format =
        AHardwareBuffer_Format(1);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM: AHardwareBuffer_Format =
        AHardwareBuffer_Format(2);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R8G8B8_UNORM: AHardwareBuffer_Format =
        AHardwareBuffer_Format(3);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R5G6B5_UNORM: AHardwareBuffer_Format =
        AHardwareBuffer_Format(4);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R16G16B16A16_FLOAT: AHardwareBuffer_Format =
        AHardwareBuffer_Format(22);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_R10G10B10A2_UNORM: AHardwareBuffer_Format =
        AHardwareBuffer_Format(43);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_BLOB: AHardwareBuffer_Format = AHardwareBuffer_Format(33);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_D16_UNORM: AHardwareBuffer_Format = AHardwareBuffer_Format(48);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_D24_UNORM: AHardwareBuffer_Format = AHardwareBuffer_Format(49);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_D24_UNORM_S8_UINT: AHardwareBuffer_Format =
        AHardwareBuffer_Format(50);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_D32_FLOAT: AHardwareBuffer_Format = AHardwareBuffer_Format(51);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_D32_FLOAT_S8_UINT: AHardwareBuffer_Format =
        AHardwareBuffer_Format(52);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_S8_UINT: AHardwareBuffer_Format = AHardwareBuffer_Format(53);
}
impl AHardwareBuffer_Format {
    pub const AHARDWAREBUFFER_FORMAT_Y8Cb8Cr8_420: AHardwareBuffer_Format =
        AHardwareBuffer_Format(35);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AHardwareBuffer_Format(pub ::std::os::raw::c_uint);
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_READ_NEVER: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(0);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_READ_RARELY: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(2);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_READ_OFTEN: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(3);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_READ_MASK: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(15);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_NEVER: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(0);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_RARELY: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(32);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_OFTEN: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(48);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_CPU_WRITE_MASK: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(240);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(256);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_FRAMEBUFFER: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(512);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_COLOR_OUTPUT: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(512);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_COMPOSER_OVERLAY: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(2048);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_PROTECTED_CONTENT: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(16384);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VIDEO_ENCODE: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(65536);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_SENSOR_DIRECT_DATA: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(8388608);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(16777216);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_CUBE_MAP: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(33554432);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(67108864);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_0: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(268435456);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_1: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(536870912);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_2: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(1073741824);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_3: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(2147483648);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_4: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(281474976710656);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_5: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(562949953421312);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_6: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(1125899906842624);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_7: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(2251799813685248);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_8: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(4503599627370496);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_9: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(9007199254740992);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_10: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(18014398509481984);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_11: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(36028797018963968);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_12: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(72057594037927936);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_13: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(144115188075855872);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_14: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(288230376151711744);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_15: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(576460752303423488);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_16: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(1152921504606846976);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_17: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(2305843009213693952);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_18: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(4611686018427387904);
}
impl AHardwareBuffer_UsageFlags {
    pub const AHARDWAREBUFFER_USAGE_VENDOR_19: AHardwareBuffer_UsageFlags =
        AHardwareBuffer_UsageFlags(9223372036854775808);
}
impl ::std::ops::BitOr<AHardwareBuffer_UsageFlags> for AHardwareBuffer_UsageFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        AHardwareBuffer_UsageFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for AHardwareBuffer_UsageFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: AHardwareBuffer_UsageFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<AHardwareBuffer_UsageFlags> for AHardwareBuffer_UsageFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        AHardwareBuffer_UsageFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for AHardwareBuffer_UsageFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: AHardwareBuffer_UsageFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AHardwareBuffer_UsageFlags(pub ::std::os::raw::c_ulong);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AHardwareBuffer_Desc {
    pub width: u32,
    pub height: u32,
    pub layers: u32,
    pub format: u32,
    pub usage: u64,
    pub stride: u32,
    pub rfu0: u32,
    pub rfu1: u64,
}
#[test]
fn bindgen_test_layout_AHardwareBuffer_Desc() {
    const UNINIT: ::std::mem::MaybeUninit<AHardwareBuffer_Desc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHardwareBuffer_Desc>(),
        40usize,
        concat!("Size of: ", stringify!(AHardwareBuffer_Desc))
    );
    assert_eq!(
        ::std::mem::align_of::<AHardwareBuffer_Desc>(),
        8usize,
        concat!("Alignment of ", stringify!(AHardwareBuffer_Desc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rfu0) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(rfu0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rfu1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Desc),
            "::",
            stringify!(rfu1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer_Plane {
    pub data: *mut ::std::os::raw::c_void,
    pub pixelStride: u32,
    pub rowStride: u32,
}
#[test]
fn bindgen_test_layout_AHardwareBuffer_Plane() {
    const UNINIT: ::std::mem::MaybeUninit<AHardwareBuffer_Plane> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHardwareBuffer_Plane>(),
        16usize,
        concat!("Size of: ", stringify!(AHardwareBuffer_Plane))
    );
    assert_eq!(
        ::std::mem::align_of::<AHardwareBuffer_Plane>(),
        8usize,
        concat!("Alignment of ", stringify!(AHardwareBuffer_Plane))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Plane),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelStride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Plane),
            "::",
            stringify!(pixelStride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowStride) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Plane),
            "::",
            stringify!(rowStride)
        )
    );
}
impl Default for AHardwareBuffer_Plane {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer_Planes {
    pub planeCount: u32,
    pub planes: [AHardwareBuffer_Plane; 4usize],
}
#[test]
fn bindgen_test_layout_AHardwareBuffer_Planes() {
    const UNINIT: ::std::mem::MaybeUninit<AHardwareBuffer_Planes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AHardwareBuffer_Planes>(),
        72usize,
        concat!("Size of: ", stringify!(AHardwareBuffer_Planes))
    );
    assert_eq!(
        ::std::mem::align_of::<AHardwareBuffer_Planes>(),
        8usize,
        concat!("Alignment of ", stringify!(AHardwareBuffer_Planes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planeCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Planes),
            "::",
            stringify!(planeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AHardwareBuffer_Planes),
            "::",
            stringify!(planes)
        )
    );
}
impl Default for AHardwareBuffer_Planes {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn AHardwareBuffer_allocate(
        desc: *const AHardwareBuffer_Desc,
        outBuffer: *mut *mut AHardwareBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_acquire(buffer: *mut AHardwareBuffer);
}
extern "C" {
    pub fn AHardwareBuffer_release(buffer: *mut AHardwareBuffer);
}
extern "C" {
    pub fn AHardwareBuffer_describe(
        buffer: *const AHardwareBuffer,
        outDesc: *mut AHardwareBuffer_Desc,
    );
}
extern "C" {
    pub fn AHardwareBuffer_lock(
        buffer: *mut AHardwareBuffer,
        usage: u64,
        fence: i32,
        rect: *const ARect,
        outVirtualAddress: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_unlock(
        buffer: *mut AHardwareBuffer,
        fence: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_sendHandleToUnixSocket(
        buffer: *const AHardwareBuffer,
        socketFd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_recvHandleFromUnixSocket(
        socketFd: ::std::os::raw::c_int,
        outBuffer: *mut *mut AHardwareBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_lockPlanes(
        buffer: *mut AHardwareBuffer,
        usage: u64,
        fence: i32,
        rect: *const ARect,
        outPlanes: *mut AHardwareBuffer_Planes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_isSupported(desc: *const AHardwareBuffer_Desc) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_lockAndGetInfo(
        buffer: *mut AHardwareBuffer,
        usage: u64,
        fence: i32,
        rect: *const ARect,
        outVirtualAddress: *mut *mut ::std::os::raw::c_void,
        outBytesPerPixel: *mut i32,
        outBytesPerStride: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AHardwareBuffer_getId(
        buffer: *const AHardwareBuffer,
        outId: *mut u64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct native_handle {
    pub version: ::std::os::raw::c_int,
    pub numFds: ::std::os::raw::c_int,
    pub numInts: ::std::os::raw::c_int,
    pub data: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_native_handle() {
    const UNINIT: ::std::mem::MaybeUninit<native_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<native_handle>(),
        12usize,
        concat!("Size of: ", stringify!(native_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<native_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(native_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(native_handle),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numFds) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(native_handle),
            "::",
            stringify!(numFds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numInts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(native_handle),
            "::",
            stringify!(numInts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(native_handle),
            "::",
            stringify!(data)
        )
    );
}
pub type native_handle_t = native_handle;
pub type buffer_handle_t = *const native_handle_t;
extern "C" {
    pub fn native_handle_close(h: *const native_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_handle_init(
        storage: *mut ::std::os::raw::c_char,
        numFds: ::std::os::raw::c_int,
        numInts: ::std::os::raw::c_int,
    ) -> *mut native_handle_t;
}
extern "C" {
    pub fn native_handle_create(
        numFds: ::std::os::raw::c_int,
        numInts: ::std::os::raw::c_int,
    ) -> *mut native_handle_t;
}
extern "C" {
    pub fn native_handle_clone(handle: *const native_handle_t) -> *mut native_handle_t;
}
extern "C" {
    pub fn native_handle_delete(h: *mut native_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the native handle from an AHardwareBuffer.\n\n \\return a non-NULL native handle on success, NULL if \\a buffer is nullptr or the operation fails\n for any reason."]
    pub fn AHardwareBuffer_getNativeHandle(
        buffer: *const AHardwareBuffer,
    ) -> *const native_handle_t;
}
impl CreateFromHandleMethod {
    pub const AHARDWAREBUFFER_CREATE_FROM_HANDLE_METHOD_REGISTER: CreateFromHandleMethod =
        CreateFromHandleMethod(2);
}
impl CreateFromHandleMethod {
    pub const AHARDWAREBUFFER_CREATE_FROM_HANDLE_METHOD_CLONE: CreateFromHandleMethod =
        CreateFromHandleMethod(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CreateFromHandleMethod(pub ::std::os::raw::c_uint);
extern "C" {
    #[doc = " Create an AHardwareBuffer from a native handle.\n\n This function wraps a native handle in an AHardwareBuffer suitable for use by applications or\n other parts of the system. The contents of desc will be returned by AHardwareBuffer_describe().\n\n If method is AHARDWAREBUFFER_CREATE_FROM_HANDLE_METHOD_REGISTER, the handle is assumed to be\n unregistered, and it will be registered/imported before being wrapped in the AHardwareBuffer.\n If successful, the AHardwareBuffer will own the handle.\n\n If method is AHARDWAREBUFFER_CREATE_FROM_HANDLE_METHOD_CLONE, the handle will be cloned and the\n clone registered. The AHardwareBuffer will own the cloned handle but not the original.\n\n \\return 0 on success, -EINVAL if \\a desc or \\a handle or outBuffer is NULL, or an error number if\n the operation fails for any reason."]
    pub fn AHardwareBuffer_createFromHandle(
        desc: *const AHardwareBuffer_Desc,
        handle: *const native_handle_t,
        method: i32,
        outBuffer: *mut *mut AHardwareBuffer,
    ) -> ::std::os::raw::c_int;
}
pub const AHARDWAREBUFFER_FORMAT_B8G8R8A8_UNORM: _bindgen_ty_1 = _bindgen_ty_1(5);
pub const AHARDWAREBUFFER_FORMAT_YV12: _bindgen_ty_1 = _bindgen_ty_1(842094169);
pub const AHARDWAREBUFFER_FORMAT_Y8: _bindgen_ty_1 = _bindgen_ty_1(538982489);
pub const AHARDWAREBUFFER_FORMAT_Y16: _bindgen_ty_1 = _bindgen_ty_1(540422489);
pub const AHARDWAREBUFFER_FORMAT_RAW16: _bindgen_ty_1 = _bindgen_ty_1(32);
pub const AHARDWAREBUFFER_FORMAT_RAW10: _bindgen_ty_1 = _bindgen_ty_1(37);
pub const AHARDWAREBUFFER_FORMAT_RAW12: _bindgen_ty_1 = _bindgen_ty_1(38);
pub const AHARDWAREBUFFER_FORMAT_RAW_OPAQUE: _bindgen_ty_1 = _bindgen_ty_1(36);
pub const AHARDWAREBUFFER_FORMAT_IMPLEMENTATION_DEFINED: _bindgen_ty_1 = _bindgen_ty_1(34);
pub const AHARDWAREBUFFER_FORMAT_YCbCr_422_SP: _bindgen_ty_1 = _bindgen_ty_1(16);
pub const AHARDWAREBUFFER_FORMAT_YCrCb_420_SP: _bindgen_ty_1 = _bindgen_ty_1(17);
pub const AHARDWAREBUFFER_FORMAT_YCbCr_422_I: _bindgen_ty_1 = _bindgen_ty_1(20);
#[repr(transparent)]
#[doc = " Buffer pixel formats."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_1(pub ::std::os::raw::c_uint);
#[repr(C, packed(4))]
pub struct cros_gralloc_handle {
    pub _base: native_handle_t,
    pub fds: [i32; 5usize],
    pub strides: [u32; 4usize],
    pub offsets: [u32; 4usize],
    pub sizes: [u32; 4usize],
    pub id: u32,
    pub width: u32,
    pub height: u32,
    pub format: u32,
    pub tiling: u32,
    pub format_modifier: u64,
    pub use_flags: u64,
    pub magic: u32,
    pub pixel_stride: u32,
    pub droid_format: i32,
    pub usage: i32,
    pub num_planes: u32,
    pub dedicated_allocation: u32,
    pub vulkan_backed: u32,
    pub memory_type_index: u32,
    pub reserved_region_size: u64,
    pub total_size: u64,
    pub name_offset: u32,
}
#[test]
fn bindgen_test_layout_cros_gralloc_handle() {
    const UNINIT: ::std::mem::MaybeUninit<cros_gralloc_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cros_gralloc_handle>(),
        168usize,
        concat!("Size of: ", stringify!(cros_gralloc_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<cros_gralloc_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(cros_gralloc_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(fds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strides) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(strides)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsets) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(offsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(sizes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tiling) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(tiling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format_modifier) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(format_modifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_flags) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(use_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_stride) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(pixel_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).droid_format) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(droid_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_planes) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(num_planes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dedicated_allocation) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(dedicated_allocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vulkan_backed) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(vulkan_backed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_type_index) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(memory_type_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_region_size) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(reserved_region_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_size) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(total_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_offset) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(cros_gralloc_handle),
            "::",
            stringify!(name_offset)
        )
    );
}
impl Default for cros_gralloc_handle {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cros_gralloc_handle_t = *const cros_gralloc_handle;
